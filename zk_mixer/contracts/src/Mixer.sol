// SPDX-License-Identifier: MIT

pragma solidity ^0.8.24;

import {IVerifier} from "./Verifier.sol";
import {IncrementalMerkleTree, Poseidon2} from "./IncrementalMerkleTree.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract Mixer is IncrementalMerkleTree, ReentrancyGuard {
    IVerifier public immutable i_verifier; // Instance of the Noir-generated verifier contract
    uint256 public DENOMINATION = 0.001 ether; // Fixed ETH amount required for deposits

    mapping(bytes32 => bool) public s_nullifierHashes; // Tracks used nullifiers to prevent double spending
    mapping(bytes32 => bool) public s_commitments; // Stores all commitments to prevent duplicate deposits

    event Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp);
    event Withdrawal(address to, bytes32 nullifierHash);

    error Mixer__DepositValueMismatch(uint256 expected, uint256 actual);
    error Mixer__PaymentFailed(address recipient, uint256 amount);
    error Mixer__NoteAlreadySpent(bytes32 nullifierHash);
    error Mixer__UnknownRoot(bytes32 root);
    error Mixer__InvalidWithdrawProof();
    error Mixer__FeeExceedsDepositValue(uint256 expected, uint256 actual);
    error Mixer__CommitmentAlreadyAdded(bytes32 commitment);

    /**
     * @dev Constructor initializes the contract with a verifier, hasher, and Merkle tree depth.
     * @param _verifier Address of the SNARK verifier contract
     * @param _hasher Address of the MiMC hash contract
     * @param _merkleTreeDepth Depth of the Merkle tree for deposits
     */
    constructor(IVerifier _verifier, Poseidon2 _hasher, uint32 _merkleTreeDepth)
        IncrementalMerkleTree(_merkleTreeDepth, _hasher)
    {
        i_verifier = _verifier;
    }

    /**
     * @dev Allows users to deposit funds into the contract. The deposit amount must match the fixed denomination.
     * @param _commitment The note commitment, calculated as Poseidon(nullifier + secret)
     */
    function deposit(bytes32 _commitment) external payable nonReentrant {
        // Ensure the commitment is not already added
        if(s_commitments[_commitment]) {
            revert Mixer__CommitmentAlreadyAdded(_commitment);
        }
        // Ensure the sent value matches the required denomination
        if (msg.value != DENOMINATION) {
            revert Mixer__DepositValueMismatch({expected: DENOMINATION, actual: msg.value});
        }

        // Mark the commitment as added
        s_commitments[_commitment] = true; 

        // Insert the commitment into the Merkle tree
        uint32 insertedIndex = _insert(_commitment); 

        emit Deposit(_commitment, insertedIndex, block.timestamp);
    }

    /**
     * @dev Allows users to withdraw a deposit from the contract using a zkSNARK proof.
     * @param _proof zkSNARK proof data
     * @param _root Merkle root of all deposits
     * @param _nullifierHash Hash of the unique deposit nullifier to prevent double spending
     * @param _recipient Address to receive the withdrawn funds
     */
    function withdraw(
        bytes calldata _proof,
        bytes32 _root,
        bytes32 _nullifierHash,
        address payable _recipient
    ) external nonReentrant {
        // Ensure the nullifier has not been used
        if (s_nullifierHashes[_nullifierHash]) {
            revert Mixer__NoteAlreadySpent({nullifierHash: _nullifierHash});
        }
        // Ensure the root is a known valid root
        if (!isKnownRoot(_root)) {
            revert Mixer__UnknownRoot({root: _root});
        }
        bytes32[] memory publicInputs = new bytes32[](3);
        publicInputs[0] = _root; // Merkle tree root
        publicInputs[1] = _nullifierHash; // Nullifier hash
        publicInputs[2] = bytes32(uint256(uint160(address(_recipient)))); // Recipient address

        // Verify the zkSNARK proof
        if (!i_verifier.verify(_proof, publicInputs)) {
            revert Mixer__InvalidWithdrawProof();
        }

        // Mark the nullifier as used and transfer the funds
        s_nullifierHashes[_nullifierHash] = true;
        (bool success,) = _recipient.call{value: DENOMINATION}("");
        if (!success) {
            revert Mixer__PaymentFailed({recipient: _recipient, amount: DENOMINATION});
        }
        emit Withdrawal(_recipient, _nullifierHash);
    }

    /*
    Notes: The private inputs are:
    * `secret`: A random number generated by the user during the deposit phase.
    * `nullifier`: Another random number (or a value derived from the `secret`), unique to this specific deposit. Its primary role is in preventing double-spending.
    * `merkleProofPath`: The set of sibling nodes in the Merkle tree that, along with the commitment, can be used to reconstruct the Merkle root. This proves the commitment's existence in the tree.
    * `merkleProofIndices`: The indices indicating the position (left or right) of each sibling node in the `merkleProofPath`.
    
    The public inputs are:
    * `_proof` (bytes): The actual ZK-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge) proof generated by the user.
    * `_root` (bytes32): The Merkle root of the commitments tree against which the user generated their proof. This root must match a known, valid root on-chain at the time of withdrawal.
    * `_nullifierHash` (bytes32): A hash of the user's private `nullifier`. This is made public during withdrawal to prevent the same deposit from being withdrawn multiple times.
    * Other common public inputs: While not detailed in every simplified example, practical implementations often include `recipient` (the address to send the withdrawn funds to), `relayerFee` (if a relayer is used to submit the transaction for enhanced privacy), and `relayerAddress`.
    */
}